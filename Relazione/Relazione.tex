\documentclass[11pt, italian, openany]{book}
% Set page margins
\usepackage[margin=2cm]{geometry}

\usepackage[]{graphicx}
\usepackage{setspace}
\usepackage{mathptmx}
\singlespace % interlinea singola
% If multiple images are to be added, a folder (path) with all the images can be added here 
\graphicspath{ {images/} }

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
}
 
% All page numbers positioned at the bottom of the page
\usepackage{fancyhdr}
\fancyhf{} % clear all header and footers
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0pt} % remove the header rule
\pagestyle{fancy}

% Changes the style of chapter headings
\usepackage{titlesec}

\titleformat{\chapter}
   {\normalfont\LARGE\bfseries}{\thechapter.}{1em}{}

% Change distance between chapter header and text
\titlespacing{\chapter}{0pt}{35pt}{\baselineskip}
\usepackage{titlesec}
\titleformat{\section}
  [hang] % <shape>
  {\normalfont\bfseries\Large} % <format>
  {} % <label>
  {0pt} % <sep>
  {} % <before code>
\renewcommand{\thesection}{} % Remove section references...
\renewcommand{\thesubsection}{\arabic{subsection}} %... from subsections

% Numbered subsections
\setcounter{secnumdepth}{3}

% Prevents LaTeX from filling out a page to the bottom
\raggedbottom

\usepackage{color}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{amsmath}
% Code Listings
\definecolor{vgreen}{RGB}{104,180,104}
\definecolor{vblue}{RGB}{49,49,255}
\definecolor{vorange}{RGB}{255,143,102}
\definecolor{vlightgrey}{RGB}{245,245,245}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\usepackage{listings}

\lstdefinestyle{code}{
    language=bash,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\begin{document}

\begin{sloppypar}
\begin{titlepage}
	\clearpage\thispagestyle{empty}
	\centering
	\vspace{1cm}

    \includegraphics[scale=0.60]{unipi-logo.png}
    
	{\normalsize \noindent Dipartimento di Informatica \\
	             Corso di Laurea in Informatica \par}
	
	\vspace{2cm}
	{\Huge \textbf{Progetto di Laboratorio di Sistemi Operativi} \par}
	\vspace{1cm}
	{\large Sistemi Operativi e Laboratorio}
	\vspace{5cm}

    \begin{minipage}[t]{0.47\textwidth}
    	{\large{ Prof. Alessio Conte}}
    \end{minipage}\hfill\begin{minipage}[t]{0.47\textwidth}\raggedleft
    	{\large {Giacomo Trapani \\ 600124 - Corso A\\ }}
    \end{minipage}

    \vspace{4cm}

	{\normalsize Anno Accademico 2020/2021 \par}

	\pagebreak

\end{titlepage}
\subsection{Premessa.}
Il progetto consiste nella progettazione e realizzazione di un \textbf{file storage} gestito da un server multithreaded in grado
di comunicare con dei client attraverso le funzioni implementate all'interno della API.

Vengono implementate le seguenti parti opzionali: flag -D, funzioni adibite alle operazioni di lock/unlock su file,
file di log, script statistiche.sh, politiche di rimpiazzamento LRU, LFU. Il codice viene sviluppato all'interno di un
\href{https://github.com/liviusi/SOL-Progetto-20-21}{repository pubblico}.

\subsection{Server.}
Il server dipende dal file di configurazione il cui nome gli viene passato come unico argomento da linea di comando;
il file passato dovr\`a rispettare la seguente sintassi, altrimenti il server non si avvier\`a:
\begin{lstlisting}[style=code]
NUMBER OF THREAD WORKERS = <num_workers>
MAXIMUM NUMBER OF STORABLE FILES = <max_files>
MAXIMUM STORAGE SIZE = <max_size>
SOCKET FILE PATH = <path/to/socket>
LOG FILE PATH = <path/to/log>
REPLACEMENT POLICY = <{0, 1, 2}> # 0 FIFO, 1 LRU, 2 LFU
\end{lstlisting}
Non vengono permesse righe vuote, un numero di spazi non standard o argomenti non validi (i.e. una stringa dove ci si aspetterebbe
un valore numerico). All'avvio il server inizializza tutte le strutture dati necessarie per un corretto funzionamento, dopodich\'e
lascia che il thread manager (i.e. il \textit{main}) si metta in ascolto di richieste e salva all'interno di una coda concorrente
(si faccia riferimento a \textit{src/data\_structures/bounded\_buffer.c} per l'implementazione) il descrittore pronto (sotto forma di stringa). A
gestire le richieste dei client risultano dunque i thread workers: questi rimangono in esecuzione fino a che non estraggono dalla
coda un messaggio che riporta come descrittore pronto "0" - interpretato come messaggio di terminazione - e segnalano
al thread manager di aver terminato la gestione di una richiesta scrivendo "0" sulla pipe di comunicazione; per processare in
maniera concreta le richieste ricevute, i thread workers chiamano al loro interno le funzioni che operano su una struttura dati
"storage\_t", utilizzata per salvare i file (ed alcuni metadati necessari per la specifica).

\subsubsection{Storage.}
L'elemento chiave dell'intero progetto \`e il filesystem implementato (si faccia riferimento a \textit{src/storage.c} per l'implementazione): la struttura dati viene
definita come una struct opaca in modo tale da forzare il chiamante ad accedervi solo ed esclusivamente attraverso i metodi
messi a disposizione dall'interfaccia fornita. I file al suo interno vengono salvati come una coppia chiave-dato all'interno di
una tabella hash (si faccia riferimento a \textit{src/data\_structures/hashtable.c} per l'implementazione): la chiave sar\`a il path assoluto del
file, il dato salvato \`e identificato dalla struttura dati interna "stored\_file\_t" (di seguito "file salvato").
Per la semantica delle operazioni sullo storage si faccia riferimento alla documentazione fornita all'interno del codice.

\paragraph*{Accessi}
Gli accessi allo storage vengono moderati da una read-write lock write-biased (si faccia riferimento a \textit{src/data\_structures/rwlock.c}
per l'implementazione): tutte le operazioni implementate che possono causare modifiche al numero di file
(e.g. "Storage\_writeFile" et similia) richiedono l'accesso alla struttura dati in scrittura, altrimenti risulta sufficiente
quello in lettura. Questo tipo di lock viene usato anche all'interno dei file salvati: fino a che si tratta di doverne leggere i campi si pu\`o
accedere in lettura, quando questi devono essere modificati risulta necessario accedere in scrittura per non creare condizioni
di corsa critica o di inconsistenza. Ne consegue che il server - essendo multithreaded - pu\`o di fatto processare molte richieste
alla volta a patto che queste non abbiano bisogno di acquisire la lock sullo storage in scrittura senza alcun tipo di collo di
bottiglia.

\paragraph{Gestione degli errori.}

Molto importante all'interno dello storage \`e la gestione degli errori; si sceglie infatti di restituire un valore
definito all'interno del progetto come "OP\_FATAL" nel caso di errori fatali che di fatto lasciano il sistema in uno stato
non consistente, "OP\_FAILURE" nel caso di un generico fallimento (e.g. quando la semantica di una delle funzioni non viene rispettata
dal chiamante) e di propagare all'esterno quelli di entrambi i tipi.

\paragraph{Politiche di rimpiazzamento.}
Essendo lo storage gestito come una cache di file, esiste la possibilit\`a di incorrere in \textit{capacity miss} e - per questo
motivo - si implementano delle politiche di rimpiazzamento in modo tale da poter scegliere una "vittima" il cui nome e contenuto
viene mandato al client che si occuper\`a di elaborarlo in maniera opportuna. \`E evidente che si possa avere capacity miss solo
a fronte di 3 delle operazioni messe a disposizione: "Storage\_openFile" (pu\`o aggiungere un file nuovo allo storage
e fargli cos\`i superare il numero massimo di file salvabili), "Storage\_writeFile" e "Storage\_appendToFile" (possono scrivere all'
interno del server una quantit\`a di dati al momento non immagazzinabile); la API richiesta per\`o dalla specifica non prevede la
possibilit\`a di permettere al client di salvare i file su disco nel caso di espulsioni a fronte di una richiesta di creazione
(di un file nuovo) e - per questo motivo - si sceglie di non far partire nessun algoritmo di rimpiazzamento a fronte di questo tipo
di richiesta preferendo restituire un errore (non fatale).

\subsection{Client.}
Il client \`e un programma che - a seguito di una analisi degli argomenti passati da linea di comando - manda al server le richieste
opportune interagendo con la API richiesta dalla specifica a patto che questi siano validi (si faccia riferimento a 
\textit{src/client.c:validate} per la semantica dei singoli flag); si richiede che gli argomenti passati a ogni comando siano validi,
che ci sia uno spazio vuoto tra il comando e l'argomento (e.g. "-f sockname" e non "-fsockname"), che ogni comando sia valido e non
risulta responsabilit\`a del client convertire path relativi in path assoluti.

\paragraph{Gestione degli errori.}
Si ricorda che l'interfaccia verso il server mette a disposizione un flag booleano "exit\_on\_fatal\_errors" per decidere quale
debba essere la risposta del client a fronte di una risposta segnalante il fatto che lo storage sia in una situazione di inconsistenza.

\paragraph{Gestione dei file espulsi o letti.}
A fronte di una espulsione o di una lettura che implichi il salvataggio dei dati sul disco, viene ricreato ricorsivamente all'interno
della directory scelta l'intero percorso verso ciascuno dei singoli file.

\subsection{Interfaccia per interagire col server.}
Come richiesto dalla specifica, viene messa a disposizione una interfaccia per interagire col server (si faccia riferimento a 
\textit{src/server\_interface.c}) che si occupa di convertire le richieste del client in richieste opportunamente leggibili dal server.
Per ognuna delle operazioni implementate viene infatti definito un campo di una enum "opcodes\_t" corrispondente e si invia
al server un buffer contenente - in primis - questo valore (per ogni richiesta viene definita una semantica precisa, si faccia riferimento
al codice anche per questa).

\pagebreak
\end{sloppypar}
\end{document}